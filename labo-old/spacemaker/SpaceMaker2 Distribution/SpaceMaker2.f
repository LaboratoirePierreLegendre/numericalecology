C Program "SpaceMaker" constructs a matrix of spatial variables, for spatialC canonical analysis of variation partitioning, based either on polynomial C or on principal coordinates of a truncated matrix of Euclidean distancesC among sites (PCNM analysis).CC To change the maximum number of objects, modify "nmax" in the mainC program PARAMETER statement and recompile program.CC A file of X or X-Y coordinates is necessary only when the spatial distributionC is irregular and/or if supplementary objects are used. CC Format of the file of coordinates --C Row 1: Number of "true" objects (n)C        Number of spatial coordinates (m): 1 for a transect, 2 for a surface, C           3 for a volume. Volumes are permitted only for PCNM analysis. C           For technical reasons, polynomials are limited by the program to C           transects or surfaces.C        Number of supplementary objects (os).C           0 if no supplementary objects are usedC Following rows: data (rows = site coordinates)CC                               (c) Daniel Borcard & Pierre Legendre, 2001, 2003C2345678901234567890123456789012345678901234567890123456789012345678901234567890      Integer nmax,n,m,os,vpp,voispol,ordpol,idatx,LUT,tragrd,hor,ver      PARAMETER (nmax=1000,mmax=3)      Real*8 D(nmax,nmax),X(nmax,nmax),E(nmax),A,Bs,Mu,epsilon      Real*8 Z(nmax,nmax),temp,moyX,moyY,minim(mmax),maxim(mmax),rangmax      Real*8 sx(nmax),sx2(nmax),xbar(nmax),sdev(nmax),corlin(nmax,nmax),     +       Xprime(nmax,nmax)      Real*8 g(nmax),sumcol(nmax),totc(nmax),beta(nmax,nmax)	  Integer number(nmax)      String nom,nomaCC Note: X is used first for the coordinates read from an input file, C       then to write the PCNM or monomial variables.CC BBEdit is set to be the 'creator' for output files      CALL F_Creator('R*ch')C      LUT=7      write(*,106)      write(*,102) nmax      write(*,*) 'Name of output file containing the PCoA eigenvalues?'      open(LUT,File=*'File of PCoA eigenvalues',Status='NEW')      inquire(unit=LUT,name=nom)      write(*,*) 'File of PCoA eigenvalues: ',nom      write(LUT,106)C      write(*,*)      write(*,*) 'Name of output file containing the spatial'      write(*,*) 'variables (PCNM or monomials)?'      open(12,File=*'File of spatial variables',Status='NEW')      inquire(unit=12,name=noma)      write(*,*) 'File of spatial variables: ',nomaC      idebug=0    4 write(*,*)      write(*,*)      +'Output the file of spatial variables in the following format:'      write(*,*) '(1) A single line per object'      write(*,*) '(2) Folded object vectors, 10 to 12 values per line'      write(*,*) '(3) Canoco input file, FREE format'      read(*,*) ichoix      if(ichoix.lt.0) then         idebug=1         ichoix=-1*ichoix         endif      if((ichoix.lt.1).or.(ichoix.gt.3)) goto 4C      write(*,*)      write(*,*) 'Sampling design:'      write(*,*) '(1) A transect with equidistant points'      write(*,*) '(2) A regular grid'      write(*,*) '(3) File containing X or X-Y coordinates'      read(*,*) idatx      C Read file of coordinates      if(idatx.eq.3) then         call ReadData(n,m,os,nmax,X,langue,LUT,idebug)         goto 50C Regular transect                     else if(idatx.eq.1) then         m=1         os=0     2        write(*,*)         write(*,*) 'Number of objects?'         read(*,*) N         if ((N.le.0).or.(N.gt.nmax)) then            write(*,*) 'You are joking, I hope?'            write(*,*) 'Maximum number = ',nmax            goto 2          endif               write(LUT,*) 'Unidimensional transect with equidistant points'               do i=1,N            X(i,1)=dfloat(i)            enddo      C Regular grid               else         m=2         os=0      15       write(*,*)         write(*,*)'Regular grid: '         write(*,*)'number of rows and columns of points (two integers)'         read (*,*) hor,ver         if((hor.le.0).or.(ver.le.0)) goto 15         n=hor*ver         if(n.gt.nmax) then            write(*,*)      +         'These dimensions yield an excessive number of points.'            write(*,*)      +         'Use a smaller grid, or redimension and recompile'            write(*,*) 'the program.'            goto 15            endif                  write(LUT,107) hor,ver         ii=1         jj=1         do i=1,n            X(i,1)=dfloat(ii)            X(i,2)=dfloat(jj)            if(ii.lt.hor) then                ii=ii+1               else               ii=1               jj=jj+1               endif            enddo         write(*,*)         write(*,*) 'Save the file of X-Y coordinates?'         write(*,*) '(0) No, (1) Yes'         read(*,*) igrille               if(igrille.eq.1) then            open (9,file='Grid.txt',status='new')            do i=1,n               write(9,108) (X(i,j), j=1,m)               enddo            close (9)                  write(*,*)            write(*,*) 'The X-Y coordinates of the points on the grid'            write(*,*) 'were written out to the file "Grid.txt" '            endif                  endif      C &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&C PCNM or polynomial?50    nbase=n      mbase=m      osbase=os      write(*,*)      write(*,*)'Do you want to construct'      write(*,*)'(1) a file of PCNM spatial variables?'      write(*,*)'(2) a file containing a polynomial of the coordinates?'      read(*,*) voispol            if((voispol.eq.2).and.(m.gt.2)) then         write(*,*)         write(*,*) 'This program can only construct a polynomial for'         write(*,*)      +      'transects or surfaces, not for',m,' geographic dimensions'         STOP         endif      call Range1(n,m,os,nmax,X,mmax,minim,maxim,rangmax,voispol,     +   LUT,idebug)      if(voispol.eq.1) goto 130C Polynomial: determine the order56    write(*,*)      write(*,*) 'Order of the polynomial? 2 to 5'      read(*,*) ordpol      if(ordpol.le.1) then         write(*,*)      +      'You don''t want to compute a polynomial of order',ordpol         write(*,*) 'Try again...'         goto 56         endif      if(ordpol.gt.5) then         write(*,*) 'The highest polynomial order in this program is 5.'         write(*,*) 'Try again...'         goto 56         endif            if(mbase.eq.1) then         m=ordpol         else         m=0         do k=1,ordpol            m=m+k+1            enddo         if((mbase.gt.1).and.(m.ge.(n-1))) then            write(*,*)      +         'A polynomial of order ',ordpol,' leads to a spatial'            write(*,*)      +         'matrix containing ',m,' monomials, which is too many:'            write(*,*)      +         'more monomials than (number of objects - 1).'            write(*,*)      +         'Please choose a smaller order for the polynomial.'            goto 56            endif         endif      write(LUT,*)      write(LUT,*) 'Constructing a polynomial of order ',ordpolC Polynomial: centre the X coordinate (the only coordinate for transects) --C Only the n first values are summed and averagedC (without the supplementary objects), because this mean will only be usedC for the centring of the X and Y coordinates of the polynomial (where the C supplementary objects are not used)      moyx=0.0      do i=1,N         moyx=moyx+X(i,1)         enddo      moyx=moyx/dfloat(N)C      write(*,*) moyx      do i=1,N         X(i,1)=X(i,1)-moyx         enddoC Construct the polynomial for one-dimensional data (transect, time series) --      if(mbase.eq.1) then         do i=1,N            do j=1,ordpol               X(i,j)=X(i,1)**j               enddo            enddo         goto 78         endifC Polynomial: centre the Y coordinate --      moyy=0.0      do i=1,N         moyy=moyy+X(i,2)         enddo      moyy=moyy/dfloat(N)C      write(*,*) moyy      do i=1,N         X(i,2)=X(i,2)-moyy         enddoC The following procedure, written by Vladimir Makarenkov, C produces the monomials in the following order C for a cubic polynomial: Y Y2 Y3 X XY XY2 X2 X2Y X3CC General rule for the order of the monomials: C first the successive powers of Y (from 1 to order); C then X with the successive powers of Y (from 0 to order-1);C then X^2 with the successive powers of Y (from 0 to order-2); etc.      do 74 i=1,n         x1=X(i,1)         y1=X(i,2)         j=1         do 76 ii=0,ordpol         do 76 jj=0,ordpol            if((ii+jj.gt.0).and.(ii+jj.le.ordpol)) then               if (((x1.eq.0.0).and.(y1.eq.0.0)).or.((x1.eq.0.0).and.     +            (ii.ne.0)).or.((y1.eq.0.0).and.(jj.ne.0))) then                   X(i,j)=0.0                  j=j+1               else if ((x1.eq.0.0).and.(ii.eq.0)) then                  X(i,j)=y1**jj                  j=j+1               else if ((y1.eq.0.0).and.(jj.eq.0)) then                  X(i,j)=x1**ii                  j=j+1               else                 X(i,j)=(x1**ii)*(y1**jj)                 j=j+1                endif            endif76       continue74    continue78    continue      goto 144C*******************************************************************************C Construct the matrix of Euclidean distances, select the truncationC distance, and compute the principal coordinates of the resulting matrixC without correction for negative eigenvalues130   epsilon=0.0000000001      write(LUT,*)      write(LUT,*) 'Matrix of PCNM spatial variables'C Start the clock      debut=secnds(0.0)C Compute the half-matrix D of Euclidean distances among sites      do 132 i = 1,(n+os-1)      do 132 j = i+1,(n+os)         A = 0.0         do k = 1,m            A = A + (X(i,k) - X(j,k))**2            enddo         D(i,j) = dsqrt(A)132      continueC Filtering the matrix of Euclidean distances: choose the lower and upperC limits of truncation, and replace the deleted values by  Mu*upper limit136   write(*,*)      write(*,*) 'Truncation of the distance matrix --'      write(*,*)      write(*,*) 'Highest unmodified value in distance matrix?'      write(*,*) 'Type an integer or a real number, ex. 1 or 65.22.'      write(*,*)      +   'Use the SAME measurement units as the site coordinates.'      read(*,*) Bs      Bs=(Bs/rangmax) + epsilon      if(idebug.eq.1) write(*,*) 'Bs/rangmax =',Bs      write(*,*)      C	  The multiplier for "large distances" is set to 4      Mu=4.0      write(LUT,117) Bs*rangmax      write(LUT,118) Mu            do 150 i = 1,(n+os-1)      do 150 j = i+1,(n+os)         if(D(i,j).gt.Bs) D(i,j)=Bs*Mu150      continueCC Make the distance matrix symmetric      do 152 i = 2,N+os      do 152 j = 1,(i-1)152      D(i,j) = D(j,i)CC Fill the diagonal of D with zeros      do i = 1,N+os         D(i,i) = 0.0         enddoC Principal coordinates on the filtrated matrix of Euclidean distances:C supplementary objects are provisionally added to the true objects. AfterC treatment by subroutine PCoA, only the principal coordinates correspondingC to the positive eigenvalues (vpp) and to the n true objects are retained.      NN=n+os            Call PCoA(NN,nmax,number,D,e,g,X,beta,sumcol,totc,vpp,LUT)      write(LUT,*) 'Eigenvalues of the PCoA:'      write(LUT,*)      write(LUT,101) (e(j), j=1,NN)            if(vpp.ge.(NN-1)) then         write(*,*)         write(*,*)'Truncation of the distance matrix using limit ',Bs         write(*,*)'yielded a PCNM matrix containing ',vpp,' variables.'         write(*,*)'There are too many PCNMs: R-square=1, not signif.'         write(*,*)'Choose a lower truncation limit.'         goto 136         else         write(*,120) Bs*rangmax,vpp         endifC Finally the matrix of spatial variables is redimensioned as follows:      m=vpp      C If supplementary objects have been used, it is interesting to verify if thereC is not too much correlation among the resulting principal coordinates, andC notify the user:      if(os.gt.0) then      call correl(n,m,X,nmax,sx,sx2,xbar,sdev,corlin,Xprime,LUT)      endifC &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&C Spatial variables (PCNM or monomials) are written out to a text file144   continue      if(ichoix.le.2) then         call WriteOut(n,mbase,m,nmax,X,ichoix,voispol,ordpol)         else         call CanocoFREE(n,mbase,m,nmax,X,voispol,ordpol)         endif      close (12)            if(voispol.eq.1) then         write(6,*)         write(6,*)'The principal coordinates with positive'         write(6,*)'eigenvalues (PCNM variables) have been'         write(6,*)'written out to file ',noma         else         write(6,*)         write(6,*)'The monomials have been written out to file ',noma         endifC Duration of the calculations      if(voispol.eq.1) then         fin=secnds(debut)         write(*,110) fin         write(LUT,110) fin         endif      write(LUT,*)      write(LUT,*) 'End of the program.'      write(*,*)      write(*,*)   'End of the program.'  100 format(1x,8F12.5,$)  101 format(1x,8F12.6)  102 format(' This program can handle a maximum of',i7,' objects.')  106 format(' Program "SpaceMaker" creates a file of PCNM'/     +       ' or polynomial spatial variables.'//     +       ' Daniel Borcard & Pierre Legendre'/     +       ' Departement de sciences biologiques'/     +       ' Universite de Montreal'/     +       '    (c) Daniel Borcard & Pierre Legendre, 2001, 2003'/)  107 format(' Regular grid containing'/     +       i7,' horizontal points'/i7,' vertical points'/)  108 format(1x,3f5.0)  110 format(/' Computation time:',f10.2,' sec.')  117 format('    Highest unmodified distance value = ',F12.3)  118 format('    Multiplier for "large distances"  = ',F12.3)  119 format(1X,F10.2,4F10.5)  120 format(' Truncation of the distance matrix to the distance',F12.3/     +       ' yielded',I5,' positive eigenvalues.')      stop      end      Subroutine WriteOut(n,mbase,m,nmax,X,ichoix,voispol,ordpol)      Integer voispol,ordpol      Real*8 X(nmax,nmax)C This subroutine writes the spatial variables (matrix X) to a file,C either one site per line, or foldedC The polynomial procedure, written by Vladimir Makarenkov, produced theC monomials in the following order: Y Y2 Y3 X XY XY2 X2 X2Y X3      write(12,*) n,mC (1) A single line per object      if(ichoix.eq.1) thenC     ** PCNM variables      if(voispol.eq.1) then         do i=1,n            write(12,102) (X(i,j), j=1,m)            enddoC     ** Polynomial         else          if(mbase.eq.1) then            if(ordpol.eq.2) then            do i=1,n               write (12,101) (X(i,j), j=1,m)               enddo            else if(ordpol.eq.3) then            do i=1,n               write (12,102) (X(i,j), j=1,m)               enddo            else if(ordpol.gt.3) then            do i=1,n               write (12,103) (X(i,j), j=1,m)               enddo            endif          else            if(ordpol.eq.2) then            do i=1,n               write(12,101) X(i,3),X(i,1),X(i,5),X(i,4),X(i,2)               enddo            else if(ordpol.eq.3) then            do i=1,n               write(12,102) X(i,4),X(i,1),X(i,7),X(i,5),X(i,2),X(i,9),     +                       X(i,8),X(i,6),X(i,3)               enddo            else if(ordpol.eq.4) then            do i=1,n               write(12,103) X(i,5),X(i,1),X(i,9),X(i,6),X(i,2),X(i,12),     +         X(i,10),X(i,7),X(i,3),X(i,14),X(i,13),X(i,11),X(i,8),     +         X(i,4)               enddo            else if(ordpol.eq.5) then            do i=1,n               write(12,103) X(i,6),X(i,1),X(i,11),X(i,7),X(i,2),     +         X(i,15),X(i,12),X(i,8),X(i,3),X(i,18),X(i,16),X(i,13),     +         X(i,9),X(i,4),X(i,20),X(i,19),X(i,17),X(i,14),X(i,10),     +         X(i,5)               enddo            endif          endif         endifCC (2) Folded object vectors, 12 values per line      elseC     ** PCNM variables      if(voispol.eq.1) then         do i=1,n            write(12,112) (X(i,j), j=1,m)            enddoC     ** Polynomial         else          if(mbase.eq.1) then            if(ordpol.eq.2) then            do i=1,n               write (12,111) (X(i,j), j=1,m)               enddo            else if(ordpol.eq.3) then            do i=1,n               write (12,112) (X(i,j), j=1,m)               enddo            else if(ordpol.gt.3) then            do i=1,n               write (12,113) (X(i,j), j=1,m)               enddo            endif          else            if(ordpol.eq.2) then            do i=1,n               write(12,111) X(i,3),X(i,1),X(i,5),X(i,4),X(i,2)               enddo            else if(ordpol.eq.3) then            do i=1,n               write(12,112) X(i,4),X(i,1),X(i,7),X(i,5),X(i,2),X(i,9),     +                       X(i,8),X(i,6),X(i,3)               enddo            else if(ordpol.eq.4) then            do i=1,n               write(12,113) X(i,5),X(i,1),X(i,9),X(i,6),X(i,2),X(i,12),     +         X(i,10),X(i,7),X(i,3),X(i,14),X(i,13),X(i,11),X(i,8),     +         X(i,4)               enddo            else if(ordpol.eq.5) then            do i=1,n               write(12,113) X(i,6),X(i,1),X(i,11),X(i,7),X(i,2),     +         X(i,15),X(i,12),X(i,8),X(i,3),X(i,18),X(i,16),X(i,13),     +         X(i,9),X(i,4),X(i,20),X(i,19),X(i,17),X(i,14),X(i,10),     +         X(i,5)               enddo            endif          endif         endif      endif      return  101 format(2000f10.5)  102 format(2000f11.6)  103 format(2000f12.7)  111 format(12f10.5)  112 format(11f11.6)  113 format(10f12.7)      end            Subroutine CanocoFREE(n,mbase,m,nmax,X,voispol,ordpol)      Integer voispol,ordpol      Real*8 X(nmax,nmax)C This subroutine writes the spatial variables (matrix X) to a fileC in Canoco FREE format.C Write the header (3 lines)      if(voispol.eq.1) then         write(12,112)         else         write(12,113)         endif      write(12,114)      write(12,*) m,nC Write the spatial variablesC     ** PCNM variables      if(voispol.eq.1) then         do i=1,n            write(12,122) (X(i,j), j=1,m)            enddoC     ** Polynomial         else          if(mbase.eq.1) then            if(ordpol.eq.2) then            do i=1,n               write (12,121) (X(i,j), j=1,m)               enddo            else if(ordpol.eq.3) then            do i=1,n               write (12,122) (X(i,j), j=1,m)               enddo            else if(ordpol.gt.3) then            do i=1,n               write (12,123) (X(i,j), j=1,m)               enddo            endif          else            if(ordpol.eq.2) then            do i=1,n               write(12,121) X(i,3),X(i,1),X(i,5),X(i,4),X(i,2)               enddo            else if(ordpol.eq.3) then            do i=1,n               write(12,122) X(i,4),X(i,1),X(i,7),X(i,5),X(i,2),X(i,9),     +                       X(i,8),X(i,6),X(i,3)               enddo            else if(ordpol.eq.4) then            do i=1,n               write(12,123) X(i,5),X(i,1),X(i,9),X(i,6),X(i,2),X(i,12),     +         X(i,10),X(i,7),X(i,3),X(i,14),X(i,13),X(i,11),X(i,8),     +         X(i,4)               enddo            else if(ordpol.eq.5) then            do i=1,n               write(12,123) X(i,6),X(i,1),X(i,11),X(i,7),X(i,2),     +         X(i,15),X(i,12),X(i,8),X(i,3),X(i,18),X(i,16),X(i,13),     +         X(i,9),X(i,4),X(i,20),X(i,19),X(i,17),X(i,14),X(i,10),     +         X(i,5)               enddo            endif          endif         endifC Write variable and object names at the end of the file      if(voispol.eq.1) then      if(m.lt.100) then         write(12,103) (j, j=1,m)         else if((m.ge.100).and.(m.lt.1000)) then         write(12,104) (j, j=1,m)                  else          write(12,105) (j, j=1,m)                  endif         endif      if(voispol.eq.2) then      if(m.lt.100) then         write(12,106) (j, j=1,m)         else if((m.ge.100).and.(m.lt.1000)) then         write(12,107) (j, j=1,m)                  else          write(12,108) (j, j=1,m)                  endif         endif      if(n.lt.100) then         write(12,109) (i, i=1,n)         else if((n.ge.100).and.(n.lt.1000)) then         write(12,110) (i, i=1,n)         else          write(12,111) (i, i=1,n)         endif      return  103 format(10('PCNM',i2,2x,:))  104 format(10('PCNM',i3,1x,:))  105 format(10('PCNM',i4,:))  106 format(10('Mono',i2,2x,:))  107 format(10('Mono',i3,1x,:))  108 format(10('Mono',i4,:))  109 format(10('Site',i2,2x,:))  110 format(10('Site',i3,1x,:))  111 format(10('Site',i4,:))  112 format('File of PCNM variables')  113 format('File of monomials')  114 format('FREE')  121 format(12f10.5)  122 format(11f11.6)  123 format(10f12.7)      end            Subroutine ReadData(n,m,os,nmax,X,langue,LUT,idebug)      Integer n,m,os      Real*8 X(nmax,nmax)      String nameeCC     Lecture du tableau de coordonnees / Read the coordinate data fileC     if(langue.eq.1) write(*,*) 'Fichier de coordonnees?'      write(*,*)      write(*,*) 'File containing the coordinates?'      open(2,file=*,Status='OLD')      inquire(unit=2,name=namee)      read(2,*) n,m,osC     if(langue.eq.1) write(LUT,103) namee,n,m,os      write(*,204) namee      write(LUT,203) namee,n,m,os            if(n+os.gt.nmax) thenC        if(langue.eq.1) write(*,101)          write(*,201)         stop         endif      do 10 i=1,n+os   10 read(2,*) (X(i,k), k=1,m)C Debug      if(idebug.eq.1) then         write(LUT,*)         write(LUT,*) 'Matrice X'         write(LUT,*)         do 14 i=1,n+os   14    write(LUT,100) (X(i,k), k=1,m)         write(LUT,*)         endif      return  100 format(1x,10F10.5)  101 format(' Trop de points. Redimensionnez le programme.')  201 format(' Too many points (sites). Redimension the program.')  103 format(/' Fichier de donnees: ',a30/     +        i6,' objets'/     +        i6,' coordonnees'/     +        i6,' objets supplementaires'/)  203 format(/' Input file: ',a30/     +        i6,' objects'/     +        i6,' coordinates'/     +        i6,' supplementary objects'/)  204 format(' Input file of coordinates: ',a30)      end      Subroutine Range1(n,m,os,nmax,X,mmax,minim,maxim,rangmax,voispol,     +   LUT,idebug)      Integer n,m,os,voispol      Real*8 X(nmax,nmax),minim(mmax),maxim(mmax),rangmaxC Rescale the coordinates in the [0,10] range.C Make sure the rescaling is the same for all dimensions.      write(*,204)       write(LUT,204)       do j=1,m         minim(j)= X(1,j)         maxim(j)= X(1,j)         enddo      do i=2,n+os         do j=1,m            if(X(i,j).lt.minim(j)) minim(j)=X(i,j)            if(X(i,j).gt.maxim(j)) maxim(j)=X(i,j)            enddo         enddo      do i=1,n+os         do j=1,m            X(i,j)=X(i,j)-minim(j)            enddo         enddo      do j=1,m         maxim(j)=maxim(j)-minim(j)         enddo      rangmax=maxim(1)      do j=2,m         if(maxim(j).gt.rangmax) rangmax=maxim(j)         enddoC Multiplying "rangmax" by 0.1 produces ranging in the interval [0, 10]      if(voispol.eq.1) rangmax=rangmax*0.1      do i=1,n+os         do j=1,m            X(i,j)=X(i,j)/rangmax            enddo         enddoC Debug      if(idebug.eq.1) then         write(*,*) 'Vector Minim =',(minim(j), j=1,m)         write(*,*) 'Vector Maxim =',(maxim(j), j=1,m)         write(*,*) 'Rangmax =',rangmax         write(*,*)         write(LUT,*)         write(LUT,*) 'Matrix X after ranging'         write(LUT,*)         do 16 i=1,n+os   16    write(LUT,100) (X(i,k), k=1,m)         write(LUT,*)         endifC      return  100 format(1x,10F10.5)  204 format(/' The coordinates were ranged and centred before',     +        ' computing the spatial variables.')      end      SUBROUTINE PCoA(n,nmax,number,D,e,g,alpha,beta,sumcol,totc,vpp,     +   LUT)C This subroutine performs Principal Coordinate Analysis (PCoA; Gower 1966).      Real*8 d(nmax,nmax),alpha(nmax,nmax),e(nmax),g(nmax),sumcol(nmax),     +       sumpos,sumneg,trace,totc(nmax),beta(nmax,nmax),AA	  Integer number(nmax),vpp,LUTC 345678901234567890123456789012345678901234567890123456789012345678901234567890      ndata=0      do 20 i=1,(n-1)      do 20 j=(i+1),n      alpha(i,j)= -0.5*(d(i,j)**2)20    alpha(j,i)=alpha(i,j)C Put zeros on diagonal of matrix alpha      do 32 i=1,n32    alpha(i,i)=0.0      call Gower(alpha,sumcol,n,nmax)      trace=0.0      do 42 i=1,n42    trace=trace+alpha(i,i)C Calculate eigenvalues of Gower-centred alpha for PCoAC TQLI returns the eigenvectors in matrix alpha      do 44 i=1,n      e(i) = 0.044    g(i) = 0.0      call tred2(alpha,n,nmax,e,g)      call tqli(e,g,n,nmax,alpha)C Put the eigenvalues and corresponding eigenvectors in descending orderC Phase 1: sort eigenvalues and vector of integers "number"      do 46 i=1,n46    number(i)=i      do 52 j = 2,n            AA = e(j)            nn=number(j)            do 48 i = j-1,1,-1C                  if (e(i).gt.AA) goto 50                  if ((e(i)-AA).gt.0.00000001) goto 50                  e(i+1) = e(i)                  number(i+1)=number(i)48                continue            i = 050          e(i+1) = AA            number(i+1)=nn52    continueCC Phase 2: Sort "alpha" according to new order of "number". Use "totc" as buffer      do 58 ii=1,n      do 54 j=1,n54    totc(j)=alpha(ii,j)      do 56 j=1,n56    alpha(ii,j)=totc(number(j))58    continueCC Normalize the principle coordinates to variance=eigenvalue      do 62 k=1,n      if(e(k).gt.0.0) then         temp=dsqrt(e(k))         else         temp=dsqrt(-e(k))         endif      do 60 i=1,n60    alpha(i,k)=alpha(i,k)*temp62    continueCC Le petit morceau qui suit pourra etre supprime plus tard:CC     Negative eigenvalues?      sumpos=0.0      sumneg=0.0      do 64 i=1,n      if(e(i).ge.0.0) then         sumpos=sumpos+e(i)         else         sumneg=sumneg+e(i)      endif   64 continue      write(LUT,*)      write(LUT,110) sumpos,sumneg,traceCC The following checks for zero eigenvalues according to the thresholdC set by the value of epsilon, and prints only the non-zero coordinates.         epsilon=0.0000005         nthresh=0         do 96 i=n,1,-1		    if (e(i).lt.epsilon) then                  nthresh=nthresh+1                  cycle                  else                  goto 97                  end if96       continue97       write(LUT,118) n-nthresh         vpp=n-nthreshC      return101   format(1x,8f10.5)110   format(/' Sum of positive eigenvalues         ',f15.5/     +        ' Sum of negative eigenvalues         ',f15.5/     +        ' Trace of Gower-centred matrix       ',f15.5)118   format(/' Number of positive eigenvalues:',I4/)      end      SUBROUTINE Gower(A,sumcol,n,nmax)C This subroutine centers the data in the manner of Gower (1966).      Real*8 A(nmax,nmax),sumcol(nmax),supmax,pp      pp=dfloat(n)      do 2 i=1,n      sumcol(i)=0.02     continue      do 4 i=1,n      do 4 j=1,n4     sumcol(j)=sumcol(j)+A(i,j)      supmax=0.      do 6 j=1,n      supmax=supmax+sumcol(j)6     sumcol(j)=sumcol(j)/pp      supmax=supmax/pp      supmax=supmax/pp      do 8 i=1,n      do 8 j=1,n8     A(i,j)=A(i,j)-sumcol(i)-sumcol(j)+supmax      return      endC Following are two subroutines for finding the eigenvalues of a realC symmetric matrix using the Householder method, a procedure recommendedC by Numerical Recipes (Press et al., 1986): routines TRED2 and TQLI.      Subroutine TRED2(A,N,NP,D,E)CC Householder reduction of a real, symmetric, N by N matrix A, stored inC an NP by NP physical array.  On output, A is replaced by the orthogonalC matrix Q effecting the transformation.  D returns the diagonal elementsC of the tridiagonal matrix, and E the off-diagonal elements, with E(1) = 0.C Several statements, as noted in comments, can be omitted if onlyC eigenvalues are to be found, in which case A contains no useful informationC on output.  Otherwise they are to be included.C      Dimension A(NP,NP), D(NP), E(NP)C REAL*8 statement added for double precision.      Real*8 A,D,E,H,SCALE,F,G,HH            IF (N.GT.1) THEN         DO 18 I = N,2,-1              L = I - 1              H = 0.              SCALE = 0.              IF (L.GT.1) THEN                 DO 11 K = 1,L                    SCALE = SCALE + DABS(A(I,K))11                  CONTINUEC              IF (SCALE.EQ.0) THEN              IF (Dabs(SCALE).lt.0.00000001) THEN                 E(I) = A(I,L)              ELSE                 DO 12 K = 1,L                    A(I,K) = A(I,K)/SCALE                    H = H + A(I,K)**212               CONTINUE                 F = A(I,L)                 G = -SIGN(DSQRT(H),F)                 E(I) = SCALE*G                 H = H-F*G                 A(I,L) = F-G                 F = 0.                 DO 15 J = 1,LC Omit following line if finding only eigenvalues.                    A(J,I) = A(I,J)/H                    G = 0.                    DO 13 K = 1,J                       G = G + A(J,K) * A(I,K)13                  CONTINUE                    IF (L.GT.J) THEN                       DO 14 K = J+1, L                          G = G + A(K,J)*A(I,K)14                     CONTINUE                    END IF                    E(J) = G/H                    F = F + E(J)*A(I,J)15                  CONTINUE                 HH = F/(H + H)                 DO 17 J = 1,L                    F = A(I,J)                    G = E(J) - HH*F                    E(J) = G                    DO 16 K = 1,J                       A(J,K) = A(J,K) - F*E(K) - G*A(I,K)16                  CONTINUE17               CONTINUE              END IF              ELSE                 E(I) = A(I,L)              END IF              D(I) = H18       CONTINUE      END IFC Omit following line if finding only eigenvalues.      D(1) = 0.      E(1) = 0.      DO 23 I = 1,NC Delete lines from here...         L = I-1C         IF (D(I).NE.0.) THEN         IF (Dabs(D(I)).gt.0.00000001) THEN            DO 21 J = 1,L               G = 0.               DO 19 K = 1,L                  G = G + A(I,K) * A(K,J)19             CONTINUE               DO 20 K = 1,L                  A(K,J) = A(K,J) - G*A(K,I)20             CONTINUE21          CONTINUE         END IFC ... to here when finding only eigenvalues.         D(I) = A(I,I)C Also delete lines from here ....         A(I,I) = 1.         IF(L.GE.1) THEN            DO 22 J = 1,L               A(I,J) = 0.               A(J,I) = 0.22          CONTINUE         END IFC ... to here when finding only eigenvalues.23    continue      return      end      SUBROUTINE TQLI (D,E,N,NP,Z)CC QL algorithm with implicit shifts, to determine the eigenvalues andC eigenvectors of a real, symmetric, tridiagonal matrix previouslyC reduced by TRED2 (Numerical Recipes).  D is a vector of length NP.C On input, its first N elements are the diagonal elements of the tridiagonalC matrix.  On output, it returns the eigenvalues.  The vector E inputs theC subdiagonal elements of the tridiagonal matrix, with E(1) arbitrary.  OnC output, E is destroyed.  When finding only the eigenvalues, several linesC may be omitted, as noted in the coments.  If the eigenvectors of theC tridiagonal matrix are desired, the matrix Z (N by N matrix stored inC NP by NP array) is input as the identity matrix.  If the eigenvectors ofC a matrix that has been reduced by TRED2 are required, then Z is input asC the matrix output by TRED2.  In either case, the Kth column of Z returnsC the normalized eigenvector corresponding to D(K).C      DIMENSION D(NP), E(NP), Z(NP,NP)C REAL*8 statement added for double precision (probably not needed)      REAL*8 D,E,Z,DD,G,R,S,C,P,F,B      IF (N.GT.1) THEN         DO 11 I = 2,N            E(I-1) = E(I)11       CONTINUE         E(N) = 0.0         DO 15 L = 1,N            ITER = 01           DO 12 M = L, N-1               DD = DABS(D(M)) + DABS(D(M+1))C               IF (DABS(E(M)) + DD.EQ.DD) GO TO 2               IF (DABS(E(M)).lt.0.00000001) GO TO 212          CONTINUE            M = N2           IF (M.NE.L) THEN               IF (ITER.EQ.50) Stop 'Too many iterations in TQLI'               ITER = ITER + 1               G = (D(L+1)-D(L))/(2.*E(L))               R = SQRT(G**2+1.)               G = D(M) - D(L) + E(L)/(G + SIGN(R,G))               S = 1.               C = 1.               P = 0.               DO 14 I = M-1,L,-1                  F = S*E(I)                  B = C*E(I)C                  IF (DABS(F).GE.DABS(G)) THEN                  IF (DABS(F)-DABS(G).gt.-0.00000001) THEN                     C = G/F                     R = DSQRT(C**2+1.)                     E(I+1) = F*R                     S = 1./R                     C = C*S                  ELSE                     S = F/G                     R = DSQRT(S**2+1.)                     E(I+1) = G*R                     C = 1./R                     S = S*C                  END IF                  G = D(I+1) - P                  R = (D(I) - G)*S+2.*C*B                  P = S*R                  D(I+1) = G + P                  G = C*R - BC Omit lines from here ...                  DO 13 K = 1,N                     F = Z(K,I+1)                     Z(K,I+1) = S*Z(K,I) + C*F                     Z(K,I) = C*Z(K,I) - S*F13                CONTINUEC ... to here when finding only eigenvalues.14             CONTINUE               D(L) = D(L) - P               E(L) = G               E(M) = 0.               GO TO 1            END IF15          CONTINUE      END IF      RETURN      END      SUBROUTINE CORREL(n,m,X,nmax,sx,sx2,xbar,sdev,corlin,Xprime,LUT)      real*8 sx(nmax),sx2(nmax),xbar(nmax),sdev(nmax),corlin(nmax,nmax),     +       X(nmax,nmax),Xprime(nmax,nmax)      real*8 corrmaxC Transformation de X / Standardization of X      do 20 k=1,m      sx(k)=0.0   20 sx2(k)=0.0      do 22 i=1,n      do 22 k=1,m      sx(k)=sx(k)+X(i,k)   22 sx2(k)=sx2(k)+X(i,k)*X(i,k)      do 24 k=1,m      xbar(k)=sx(k)/dfloat(n)   24 sdev(k)=dsqrt((sx2(k)-(sx(k)**2/dfloat(n)))/dfloat(n-1))      do 26 k=1,mC      if(sdev(k).eq.0.0) then      if(sdev(k).lt.0.00000001) then      write(LUT,*) 'Variance nulle pour variable X no ',kC    if(langue.eq.1) write(LUT,*) 'Variance nulle pour variable X no ',kC    if(langue.eq.2) write(LUT,*) 'Variance = 0 for variable X no. ',k         stop         endif26       continue      do 28 i=1,n      do 28 k=1,m28    X(i,k)=(X(i,k)-xbar(k))/sdev(k)C Calcul de la matrice de correlation/Computation of correlation matrix      do 30 i=1,n      do 30 j=1,m30    Xprime(j,i)=X(i,j)      call produit(Xprime,X,corlin,m,n,m,nmax)      do 32 ii=1,m      do 32 kk=1,m32    corlin(ii,kk)=corlin(ii,kk)/(n-1)      C The correlation matrix is in corlin. C Now find the highest value (corrmax) and ask the user if it is tolerable.      corrmax=0.0      do 35 i=1,m-1      do 35 j=i+1,m      if (dabs(corlin(i,j)).ge.corrmax) then         corrmax=corlin(i,j)         endif35    continue      write(*,*)      write(*,*) 'The use of supplementary objects in the computations'      write(*,*) 'induces correlations among the spatial variables.'      write(*,200) corrmax      write(*,*) 'If you find this value acceptable, keep the matrix of'      write(*,*) 'PCNM variables built by this program. If you find '      write(*,*) 'this value too high, rerun the program using fewer'      write(*,*) 'supplementary objects.'      write(LUT,201) corrmax      200   format(' The largest (absolute) correlation value is',F7.4)201   format(/' Largest absolute correlation value between two',     +        ' spatial variables:',F7.4)      return      end                  Subroutine Produit(Z1,Z2,Z3,n1,n2,n3,nmax)      Real*8 Z1(nmax,nmax),Z2(nmax,nmax),Z3(nmax,nmax),tempC Z1 * Z2 = Z3      do 8 i=1,n1      do 8 j=1,n3      temp=0.0      do 6 k=1,n2    6 temp=temp+Z1(i,k)*Z2(k,j)    8 Z3(i,j)=temp      return      end